{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n\n    //Looking through walls \n    // while(currentNode.status === \"wall\" && unsupervisedNodes.length){\n    //     currentNode = getClosestNode(nodes, unvisitedNodes);\n    // }\n    //Handling the impossible later\n    //if(closestNode.distance === Infinity) return false;\n    //Animating it\n    //nodesToAnimate.push(closestNode);\n    closestNode.isVisited = true;\n    if (closestNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid.length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","push","filter"],"sources":["C:/Users/Alfred/Desktop/AlgoVisualizer/my-app/src/algovis/algorithms/dijkstra.js"],"sourcesContent":["export function dijkstra(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(!!unvisitedNodes.length){\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n\r\n        //Looking through walls \r\n        // while(currentNode.status === \"wall\" && unsupervisedNodes.length){\r\n        //     currentNode = getClosestNode(nodes, unvisitedNodes);\r\n        // }\r\n        //Handling the impossible later\r\n        //if(closestNode.distance === Infinity) return false;\r\n        //Animating it\r\n        //nodesToAnimate.push(closestNode);\r\n        closestNode.isVisited = true;\r\n        if(closestNode === finishNode){\r\n            return visitedNodesInOrder;\r\n        }\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes){\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid){\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n    for(const neighbor of unvisitedNeighbors){\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row - 1][col]);\r\n    if(row < grid.length - 1)neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col - 1]);\r\n    if(col < grid.length - 1) neighbors.push(grid[row][col + 1])\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n"],"mappings":"AAAA,OAAO,SAASA,QAAQA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAC;EACjD,MAAMC,mBAAmB,GAAG,EAAE;EAC9BF,SAAS,CAACG,QAAQ,GAAG,CAAC;EACtB,MAAMC,cAAc,GAAGC,WAAW,CAACN,IAAI,CAAC;EAExC,OAAM,CAAC,CAACK,cAAc,CAACE,MAAM,EAAC;IAC1BC,mBAAmB,CAACH,cAAc,CAAC;IACnC,MAAMI,WAAW,GAAGJ,cAAc,CAACK,KAAK,CAAC,CAAC;;IAE1C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAD,WAAW,CAACE,SAAS,GAAG,IAAI;IAC5B,IAAGF,WAAW,KAAKP,UAAU,EAAC;MAC1B,OAAOC,mBAAmB;IAC9B;IACAS,wBAAwB,CAACH,WAAW,EAAET,IAAI,CAAC;EAC/C;AACJ;AAEA,SAASQ,mBAAmBA,CAACH,cAAc,EAAC;EACxCA,cAAc,CAACQ,IAAI,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAKD,KAAK,CAACV,QAAQ,GAAGW,KAAK,CAACX,QAAQ,CAAC;AAC1E;AAEA,SAASQ,wBAAwBA,CAACI,IAAI,EAAEhB,IAAI,EAAC;EACzC,MAAMiB,kBAAkB,GAAGC,qBAAqB,CAACF,IAAI,EAAEhB,IAAI,CAAC;EAE5D,KAAI,MAAMmB,QAAQ,IAAIF,kBAAkB,EAAC;IACrCE,QAAQ,CAACf,QAAQ,GAAGY,IAAI,CAACZ,QAAQ,GAAG,CAAC;IACrCe,QAAQ,CAACC,YAAY,GAAGJ,IAAI;EAChC;AACJ;AAEA,SAASE,qBAAqBA,CAACF,IAAI,EAAEhB,IAAI,EAAC;EACtC,MAAMqB,SAAS,GAAG,EAAE;EACpB,MAAM;IAACC,GAAG;IAAEC;EAAG,CAAC,GAAGP,IAAI;EAEvB,IAAGO,GAAG,GAAG,CAAC,EAAEF,SAAS,CAACG,IAAI,CAACxB,IAAI,CAACuB,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC9C,IAAGC,GAAG,GAAGvB,IAAI,CAACO,MAAM,GAAG,CAAC,EAACc,SAAS,CAACG,IAAI,CAACxB,IAAI,CAACuB,GAAG,GAAG,CAAC,CAAC,CAACD,GAAG,CAAC,CAAC;EAC3D,IAAGA,GAAG,GAAG,CAAC,EAAED,SAAS,CAACG,IAAI,CAACxB,IAAI,CAACuB,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAC9C,IAAGA,GAAG,GAAGtB,IAAI,CAACO,MAAM,GAAG,CAAC,EAAEc,SAAS,CAACG,IAAI,CAACxB,IAAI,CAACuB,GAAG,CAAC,CAACD,GAAG,GAAG,CAAC,CAAC,CAAC;EAE5D,OAAOD,SAAS,CAACI,MAAM,CAACN,QAAQ,IAAI,CAACA,QAAQ,CAACR,SAAS,CAAC;AAC5D"},"metadata":{},"sourceType":"module","externalDependencies":[]}